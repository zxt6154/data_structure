//// Created by alice on 2023/10/17.///* 此算法类似于迷宫寻路算法 * 假设以二维数组g(1…m, 1…n)表示一个图像区域，g[i,j]表示该区域中点(i,j)所具颜色， * 其值为从0到k的整数。编写算法置换点(i0,j0)所在区域的颜色。 * 约定和(i0,j0)同色的上、下、左、右的邻接点为同色区域的点。*/// 宏定义#include "Status.h"#define SleepTime 2#define Row 10#define Col 17typedef enum { East, South, West, North} Direction_z;typedef enum {Color_1, Color_2, Color_3} Color_z;/* 栈的元素类型 */typedef struct {    int x,y;    int di;} SElemType_z;void MazesDesizing(int g[][Col], SElemType_z start);void InitGraph_z(int g[][Col], SElemType_z* start);void PaintGraph_z(int g[][Col]);// 判断某个点是否需要染色Status Pass_z(SElemType_z start, int g[][Col]);// 遇到可以染色的点即留下标记，即染上相应的颜色void Mark_z(SElemType_z* start, int g[][Col]);// 获取下一个该染色的点的信息Status NextPos_z(SElemType_z* start);// 判断当前的点是否出界Status IsCross_z(SElemType_z start);int main(int argc, char** argv) {    int g_z[Row][Col]; // 存放图像区域点的颜色    SElemType_z start;  //染色的起点    InitGraph_z(g_z, &start);    PaintGraph_z(g_z);    MazesDesizing(g_z, start);    return 0;}//对指定的图像染色void MazesDesizing(int g[][Col], SElemType_z start) {    SElemType_z  start_z;    SElemType_z stack_z[1000];    int top = -1;    start_z = start;    do {        if(Pass_z(start_z, g)) {            Mark_z(&start_z, g);            PaintGraph_z(g);            stack_z[++top] = start_z; // 将访问过的像素点入栈            NextPos_z(&start_z);        }        else {            if(top != -1) {                start_z = stack_z[top--];                //栈中弹出的点已没多余方向可访问                while (start_z.di == North && top != -1) {                    start_z = stack_z[top--];                }                if(start_z.di < North) {                    start_z.di++;                    stack_z[++top] = start_z;                    NextPos_z(&start_z);                }            }        }    } while(top != -1);}void InitGraph_z(int g[][Col], SElemType_z* start) {    int k,l;    int a[Row][Col] = {            {0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0},            {0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0},            {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},            {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},            {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},            {0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0},            {0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0},            {0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0},            {0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0},            {0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0}    };    for (k = 0; k < Row; ++k) {        for (l = 0; l < Col; ++l) {            g[k][l] = a[k][l];        }    }    (*start).x = 9;    (*start).y = 8;    (*start).di = East; // East代表方向向右}void PaintGraph_z(int g[][Col]) {    int i, j;    Wait(SleepTime);    for(i = 0; i < Row; i++) {        for(j = 0; j < Col; j++) {            // 颜色0用"^"显示            if(g[i][j] == Color_1) {                printf(".");            }            // 颜色1显示为空白            if(g[i][j] == Color_2) {                printf(" ");            }            // 颜色2用"*"显示            if(g[i][j] == Color_3) {                printf("*");            }            if(j && !(j % (Col - 1))) {                printf("\n");            }        }    }    printf("\n");}// 判断某个点是否需要染色Status Pass_z(SElemType_z start, int g[][Col]) {    int x = start.x;    int y = start.y;    if(g[x][y] == 1) {        return TRUE;    } else {        return FALSE;    }}// 遇到可以染色的点即留下标记，即染上相应的颜色void Mark_z(SElemType_z* start, int g[][Col]) {    int x = (*start).x;    int y = (*start).y;    (*start).di = East; // 标记此像素点的前进方向    g[x][y] = 2; // 将此像素点颜色染为颜色2}// 获取下一个该染色的点的信息Status NextPos_z(SElemType_z* start){    SElemType_z tmp;    tmp = *start;    switch (tmp.di) {        case East: (tmp.y)++;            break;        case South: (tmp.x)++;            break;        case West: (tmp.y)--;            break;        case North: (tmp.x)--;            break;        default: return FALSE;    }    if(IsCross_z(*start)) {        ++(*start).di;        NextPos_z(start);    } else {        *start = tmp;    }    return TRUE;}// 判断当前的点是否出界Status IsCross_z(SElemType_z start){    int x = start.x;    int y = start.y;    if(x < 0 || y < 0 || x > Row - 1 || y > Col - 1) {        return OK;    } else {        return ERROR;    }}