#include <stdio.h>#include <stdlib.h>#include "03.12.h"#include "SqQue_03_12.h"int main(int argc, char* argv[]) {//    int sum = 1;//    digui(4, &sum);//    printf("--- %d ", sum);    test0313();}Status test0313() {    SqQue_0312 Q;    InitQueue_0312(&Q);    QueElem_0312  q1 = 10;    EnQue_0312(&Q,q1);    QueElem_0312  q2 = 12;    EnQue_0312(&Q,q2);    QueElem_0312  q3 = 3;    EnQue_0312(&Q,q3);    QueElem_0312  q4 = 2;    EnQue_0312(&Q,q4);    QueElem_0312  q5 = 7;    EnQue_0312(&Q,q5);    QueElem_0312  q6 = 9;    EnQue_0312(&Q,q6);    QueElem_0312  q7 = 5;    EnQue_0312(&Q,q7);    QueElem_0312  q8 = 10;    EnQue_0312(&Q,q8);    Quetraverse_0312(Q, PrintElemI);    Stack S;    int d;    StackInit(&S);    while(!QueueEmpty_0312(Q))    {        DeQue_0312(&Q, &d);        PushElem(&S, d);    }    while(!IfStackEmpty(S))    {        PopElem(&S, &d);        EnQue_0312(&Q, d);    }    Quetraverse_0312(Q, PrintElemI);    return OK;}Status test0312(QueueDef* Q) {    char x = 'e', y = 'c';    EnQue(Q, 'h');    EnQue(Q, 'r'); //rh    EnQue(Q, y); // crh    //DeQue(Q, &x); // hr    EnQue(Q, x); //ehr    //DeQue(Q, &x); // hr    EnQue(Q, 'a'); //ahr//    while (!IfQueEmpty(*Q)) {//        DeQue(Q, &y);////        printf(" %c", y);//    }//    printf("---");//    printf(" %c", x);    QueTraverse(Q, PrintElemC);    return OK;}Status QueTraverse(QueueDef* Q, void(Visit)(QUElemType)) {    int i;    if((*Q).base == NULL) {return ERROR;}    for (i = (*Q).front; i != (*Q).rear ; i = (i+1)%MAX_QUE_LEN) {        Visit((*Q).base[i]);    }    return OK;}// 测试函数，打印元素void PrintElemC(QUElemType e) {    printf("-- %c -- ", e);}void PrintElemI(QueElem_0312 e) {    printf("-- %d -- ", e);}Status QueueInit(QueueDef* Q) {    if(Q == NULL) {return ERROR;}    (*Q).base = (QUElemType*)malloc(MAX_QUE_LEN*sizeof(QUElemType));    if(!(*Q).base) { exit(OVERFLOW);}    (*Q).front = (*Q).rear = 0;    return OK;}Status StackInit(Stack* S) {    if(S == NULL) {return ERROR;}    (*S).base = (StackElemType*) malloc(MAX_STACK_LEN * sizeof(StackElemType));    if((*S).base == NULL) {        exit(OVERFLOW);    }    (*S).top = (*S).base;    (*S).stackSize = MAX_STACK_LEN;    return OK;}Status IfQueEmpty(QueueDef Q) {    if(Q.front == Q.rear) {return TRUE;}    else {return FALSE;}}Status IfStackEmpty(Stack S) {    if(S.top == S.base) {return TRUE;}    else {return ERROR;}}int QueLen(QueueDef Q) {    if(Q.base ==NULL) {return 0;}    return (Q.rear - Q.front + MAX_QUE_LEN) % MAX_QUE_LEN;}Status HeadGet(QueueDef Q, QUElemType* e) {    if(Q.base == NULL || Q.front == Q.rear) {return ERROR;}    *e = Q.base[Q.front];    return OK;}Status EnQue(QueueDef* Q, QUElemType e){    if(Q == NULL || (*Q).base == NULL) {return ERROR;}    // 队列满的标志（会浪费一个空间来却分队列空和队列满）    if(((*Q).rear + 1)%MAX_QUE_LEN == (*Q).front) {return ERROR;}    (*Q).base[(*Q).rear] = e;    (*Q).rear = ((*Q).rear + 1) % MAX_QUE_LEN;;    return OK;}/* * 压入栈底 */Status PushElem(Stack* S, StackElemType e) {    if(S == NULL || (*S).base == NULL) {return ERROR;}    //栈满时追加存储空间    StackElemType* a = (*S).top;    StackElemType* b = (*S).base;    int c = a - b;    int i = (*S).stackSize;    if((*S).top - (*S).base >= (*S).stackSize) {        (*S).base = (StackElemType*) realloc((*S).base, ((*S).stackSize + STACKINCREMENT) *sizeof(StackElemType));        if((*S).base == NULL) {exit(OVERFLOW);}        (*S).top = (*S).base + (*S).stackSize;        (*S).stackSize += STACKINCREMENT;    }    *(S->top++) = e;    return OK;}Status DeQue(QueueDef* Q, QUElemType* e) {    if(Q == NULL || (*Q).base == NULL) {return ERROR;}    if((*Q).front == (*Q).rear) {return ERROR;}    // 出队    *e = (*Q).base[(*Q).front];    //头指针前进    (*Q).front = ((*Q).front + 1 ) % MAX_QUE_LEN;    return OK;}Status PopElem(Stack* S, StackElemType* e) {    if(S == NULL ||(*S).base == NULL){return ERROR;}    if((*S).top == (*S).base) {return ERROR;}    // 出栈顶的指针线递减再赋值    *e = *(--(*S).top);    return OK;}