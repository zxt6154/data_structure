#ifndef CLION_03_12_H#define CLION_03_12_H#include "Status.h"// 宏定义 最大队列长度#define MAX_QUE_LEN 1000#define MAX_STACK_LEN 2#define STACKINCREMENT  10// 循环队列元素类型定义typedef char QUElemType;void PrintElemC(QUElemType e);// 循环队列的顺序存储结构typedef struct {    QUElemType* base;    int front;    int rear;} QueueDef;typedef int StackElemType;typedef struct {    StackElemType* base; //栈底指针    StackElemType* top;  //栈顶指针    int stackSize; //当前已分配的存储空间 以元素为单位} Stack;typedef struct {    void* base;    int size;    Stack block;} Space;/* *初始化 * 构造一个空的顺序队列 * 初始化成功返回OK,否则ERROR * * 循环队列 */ Status QueueInit(QueueDef* Q); Status StackInit(Stack* S); /*  * 判空  * 判断循环队列中是否包含有效数据  * 返回：  * TRUE 循环队列为空  * FALSE: 循环队列不为空  */ Status IfQueEmpty(QueueDef Q); Status IfStackEmpty(Stack S); /*  * 计数 返回循环队列包含的有效元素数量  */int QueLen(QueueDef Q);/* * 取值 * 获取队头元素，将去存储到e中 * 如果可以好到返回OK */Status HeadGet(QueueDef Q, QUElemType* e);/* * 入队 * 将元素e添加到队列尾部 */Status EnQue(QueueDef* Q, QUElemType e);Status PushElem(Stack* S, StackElemType e);/* * 出队 * 移除队列头部的元素，将其存储到e */Status DeQue(QueueDef* Q, QUElemType* e);Status PopElem(Stack* S, StackElemType* e);Status QueTraverse(QueueDef* Q, void(Visit)(QUElemType));Status test0312(QueueDef* Q);Status test0313();#endif //CLION_03_12_H