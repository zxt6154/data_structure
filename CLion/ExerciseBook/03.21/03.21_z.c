//// Created by alice on 2023/10/18.//#include <stdio.h>#include <string.h>   // 提供strlen原型#include <ctype.h>    // 提供isalpha原型#include "SqStack.h"static const char OP[] = {'+', '-', '*', '/'};/* * 运算符优先级表，与上面的OP表是呼应的。 * 这里只有四则运算符号的优先级 */static const char PrecedeTable[7][7] = {        {'>', '>', '<', '<'},        {'>', '>', '<', '<'},        {'>', '>', '>', '>'},        {'>', '>', '>', '>'}};/* * 根据给定的中缀表达式，返回其对应的逆波兰表达式（后缀表达式） * 如将"a+b*c-d/e"将转化为："abc*+de/-" * *【注】 * 表达式的变量为单字母，操作符只有'+'、'-'、'*'、'/'四则运算 */char* SuffixExpre(char s[]);/* * 判断运算符栈中操作符o1与表达式中的操作符o2的优先级。 * * 返回'>'、'<'、'='，以指示o1和o2的优先级 */char Precede_z(char c1, char c2);int main(int argc, char* argv[]) {    char* s = "a+b*c-f+g-h*d/e";    printf("中缀表达式为: ");    printf("%s\n", s);    printf("后缀表达式为: "); // abc*+de/-    printf("%s\n", SuffixExpre(s));    return 0;}char* SuffixExpre(char s[]) {    int i,j;    char* sufExp;    sufExp = (char*) malloc((strlen(s) + 1)* sizeof(char));    SqStack S;    SElemType e;    InitStack(&S);    // a+b*c-f+g-h*d/e    for(i = j = 0; s[i] != '\0'; i++) {        // 如果读到了字母，将其视为操作数，       int flag =  isalpha(s[i]);        printf("%c <------> %d\n", s[i], flag);        if(flag) {            sufExp[j++] = s[i];  // 将字母直接存入逆波兰式中        }        // 如果是运算符        else {            while(!StackEmpty(S))  { //如果运算符栈不为空                GetTop(S, &e);                if(Precede_z(e, s[i]) == '>') {                    Pop(&S, &e); //  // 将运算符栈中优先级高的操作符出栈                    sufExp[j++] = e;                } else { break;}            }            Push(&S, s[i]);        }    }    while (!StackEmpty(S)) {        Pop(&S, &e);        sufExp[j++] = e;    }    // 数组中转换后的逆波兰式以"\0"标记结束    sufExp[j] = '\0';    return sufExp;}// 计算出一个运算符优先级表坐标 + *char Precede_z(char c1, char c2) {    int x,y;    // 获取指定的运算符在运算符表中的位置    char* p1 = strchr(OP, c1);    char* p2 = strchr(OP, c2);    x = p1 - OP;    y = p2 - OP;    return PrecedeTable[x][y];}