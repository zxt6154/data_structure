#include <stdlib.h>#include <limits.h>#include "Status.h"typedef int QElemType_z;/* 队列节点类型 */typedef struct QNode_z {    QElemType_z data;    struct QNode_z* next;} QNode_z, * QueuePtr_z;/*队列结构*/typedef struct {    QueuePtr_z rear; // 队尾指针} LinkQueue_z;  // 队列的链式存储表示//队列初始化Status QueInit_3_28(LinkQueue_z* Q);// 入队Status  QueEn_3_28(LinkQueue_z* Q, QElemType_z e);//出队Status QueDe_3_28(LinkQueue_z* Q, QElemType_z* e);// 输出队列元素void Output_z(LinkQueue_z Q);int main(int argc, char* argv[]) {    LinkQueue_z  Q;    int i;    QElemType_z  e;    printf("████ 初始化队列...\n");    QueInit_3_28(&Q);    printf("████ 进行 5 次连续入队操作...\n");    for(i = 1; i <= 5; i++) {        QueEn_3_28(&Q, i);        printf("█ 元素 \"%d\" 入队后，队列中的元素为：", i);        Output_z(Q);    }    printf("████ 进行 5 次连续出队操作...\n");    for (i = 1; i <= 5; i++) {        QueDe_3_28(&Q, &e);        printf("█ 元素 \"%d\" 出队后，队列中的元素为：", e);        Output_z(Q);    }    return 0;}//队列初始化Status QueInit_3_28(LinkQueue_z* Q) {    if(Q == NULL) {        return ERROR;    }    //创建头节点    (*Q).rear = (QueuePtr_z)malloc(sizeof(QNode_z));    if((*Q).rear == NULL) {        exit(OVERFLOW);    }    //头节点数据    (*Q).rear->data = INT_MAX;    // 循环队列 首尾相接    (*Q).rear->next = (*Q).rear;    return OK;}// 入队Status QueEn_3_28(LinkQueue_z* Q, QElemType_z e) {    QueuePtr_z p;    if(Q == NULL ||((*Q).rear) == NULL) {        return ERROR;    }    // 创建新结点 链式队列    p = (QueuePtr_z) malloc(sizeof(QNode_z));    if(p == NULL) {        exit(OVERFLOW);    }    p->data = e;    p->next = (*Q).rear->next;    (*Q).rear->next = p;    (*Q).rear = p;    return OK;}//出队Status QueDe_3_28(LinkQueue_z* Q, QElemType_z* e) {    QueuePtr_z h,p;    if(Q == NULL || (*Q).rear == NULL) {        return ERROR;    }    // 获取头结点    h = (*Q).rear->next;    // 如果只有一个头结点说明没有元素无法队列    if(h == (*Q).rear) {        return ERROR;    }    // 指向待移除元素    p = h->next;    *e = p->data;    h->next = p->next;    // 如果只有一个元素    if(p == (*Q).rear) {        //更新队尾游标        (*Q).rear = h;    }    free(p);    return OK;}void Output_z(LinkQueue_z Q) {    QueuePtr_z  p;    if(Q.rear == NULL) {        printf("\n");        return;    }    for(p = Q.rear->next->next; p!= Q.rear->next; p = p->next) {        printf("%d", p->data);    }    printf("\n");}